// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateCustomer {
  count: Int!
}

type AggregateManager {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregateOrderItem {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Customer {
  id: UUID!
  email: String!
  name: String!
  password: String!
  cpf: String!
  birthDate: DateTime!
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
  createdAt: DateTime!
  updatedAt: DateTime!
  deleted: Boolean!
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  id: UUID
  email: String!
  name: String!
  password: String!
  cpf: String!
  birthDate: DateTime!
  orders: OrderCreateManyWithoutCustomerInput
  deleted: Boolean
}

input CustomerCreateOneWithoutOrdersInput {
  create: CustomerCreateWithoutOrdersInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateWithoutOrdersInput {
  id: UUID
  email: String!
  name: String!
  password: String!
  cpf: String!
  birthDate: DateTime!
  deleted: Boolean
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  cpf_ASC
  cpf_DESC
  birthDate_ASC
  birthDate_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deleted_ASC
  deleted_DESC
}

type CustomerPreviousValues {
  id: UUID!
  email: String!
  name: String!
  password: String!
  cpf: String!
  birthDate: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
  deleted: Boolean!
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
  AND: [CustomerSubscriptionWhereInput!]
  OR: [CustomerSubscriptionWhereInput!]
  NOT: [CustomerSubscriptionWhereInput!]
}

input CustomerUpdateInput {
  email: String
  name: String
  password: String
  cpf: String
  birthDate: DateTime
  orders: OrderUpdateManyWithoutCustomerInput
  deleted: Boolean
}

input CustomerUpdateManyMutationInput {
  email: String
  name: String
  password: String
  cpf: String
  birthDate: DateTime
  deleted: Boolean
}

input CustomerUpdateOneRequiredWithoutOrdersInput {
  create: CustomerCreateWithoutOrdersInput
  update: CustomerUpdateWithoutOrdersDataInput
  upsert: CustomerUpsertWithoutOrdersInput
  connect: CustomerWhereUniqueInput
}

input CustomerUpdateWithoutOrdersDataInput {
  email: String
  name: String
  password: String
  cpf: String
  birthDate: DateTime
  deleted: Boolean
}

input CustomerUpsertWithoutOrdersInput {
  update: CustomerUpdateWithoutOrdersDataInput!
  create: CustomerCreateWithoutOrdersInput!
}

input CustomerWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  cpf: String
  cpf_not: String
  cpf_in: [String!]
  cpf_not_in: [String!]
  cpf_lt: String
  cpf_lte: String
  cpf_gt: String
  cpf_gte: String
  cpf_contains: String
  cpf_not_contains: String
  cpf_starts_with: String
  cpf_not_starts_with: String
  cpf_ends_with: String
  cpf_not_ends_with: String
  birthDate: DateTime
  birthDate_not: DateTime
  birthDate_in: [DateTime!]
  birthDate_not_in: [DateTime!]
  birthDate_lt: DateTime
  birthDate_lte: DateTime
  birthDate_gt: DateTime
  birthDate_gte: DateTime
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input CustomerWhereUniqueInput {
  id: UUID
  email: String
  cpf: String
}

scalar DateTime

scalar Long

type Manager {
  id: UUID!
  email: String!
  name: String!
  password: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  deleted: Boolean!
}

type ManagerConnection {
  pageInfo: PageInfo!
  edges: [ManagerEdge]!
  aggregate: AggregateManager!
}

input ManagerCreateInput {
  id: UUID
  email: String!
  name: String!
  password: String!
  deleted: Boolean
}

type ManagerEdge {
  node: Manager!
  cursor: String!
}

enum ManagerOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deleted_ASC
  deleted_DESC
}

type ManagerPreviousValues {
  id: UUID!
  email: String!
  name: String!
  password: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  deleted: Boolean!
}

type ManagerSubscriptionPayload {
  mutation: MutationType!
  node: Manager
  updatedFields: [String!]
  previousValues: ManagerPreviousValues
}

input ManagerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ManagerWhereInput
  AND: [ManagerSubscriptionWhereInput!]
  OR: [ManagerSubscriptionWhereInput!]
  NOT: [ManagerSubscriptionWhereInput!]
}

input ManagerUpdateInput {
  email: String
  name: String
  password: String
  deleted: Boolean
}

input ManagerUpdateManyMutationInput {
  email: String
  name: String
  password: String
  deleted: Boolean
}

input ManagerWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  AND: [ManagerWhereInput!]
  OR: [ManagerWhereInput!]
  NOT: [ManagerWhereInput!]
}

input ManagerWhereUniqueInput {
  id: UUID
  email: String
}

type Mutation {
  createCustomer(data: CustomerCreateInput!): Customer!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateManyCustomers(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  createManager(data: ManagerCreateInput!): Manager!
  updateManager(data: ManagerUpdateInput!, where: ManagerWhereUniqueInput!): Manager
  updateManyManagers(data: ManagerUpdateManyMutationInput!, where: ManagerWhereInput): BatchPayload!
  upsertManager(where: ManagerWhereUniqueInput!, create: ManagerCreateInput!, update: ManagerUpdateInput!): Manager!
  deleteManager(where: ManagerWhereUniqueInput!): Manager
  deleteManyManagers(where: ManagerWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createOrderItem(data: OrderItemCreateInput!): OrderItem!
  updateOrderItem(data: OrderItemUpdateInput!, where: OrderItemWhereUniqueInput!): OrderItem
  updateManyOrderItems(data: OrderItemUpdateManyMutationInput!, where: OrderItemWhereInput): BatchPayload!
  upsertOrderItem(where: OrderItemWhereUniqueInput!, create: OrderItemCreateInput!, update: OrderItemUpdateInput!): OrderItem!
  deleteOrderItem(where: OrderItemWhereUniqueInput!): OrderItem
  deleteManyOrderItems(where: OrderItemWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: UUID!
  subTotal: Float!
  total: Float!
  orderItens(where: OrderItemWhereInput, orderBy: OrderItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderItem!]
  statusOrder: StatusOrder!
  customer: Customer!
  createdAt: DateTime!
  updatedAt: DateTime!
  deleted: Boolean!
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: UUID
  subTotal: Float!
  total: Float!
  orderItens: OrderItemCreateManyWithoutOrderInput
  statusOrder: StatusOrder
  customer: CustomerCreateOneWithoutOrdersInput!
  deleted: Boolean
}

input OrderCreateManyWithoutCustomerInput {
  create: [OrderCreateWithoutCustomerInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateOneWithoutOrderItensInput {
  create: OrderCreateWithoutOrderItensInput
  connect: OrderWhereUniqueInput
}

input OrderCreateWithoutCustomerInput {
  id: UUID
  subTotal: Float!
  total: Float!
  orderItens: OrderItemCreateManyWithoutOrderInput
  statusOrder: StatusOrder
  deleted: Boolean
}

input OrderCreateWithoutOrderItensInput {
  id: UUID
  subTotal: Float!
  total: Float!
  statusOrder: StatusOrder
  customer: CustomerCreateOneWithoutOrdersInput!
  deleted: Boolean
}

type OrderEdge {
  node: Order!
  cursor: String!
}

type OrderItem {
  id: UUID!
  quantity: Int!
  price: Float!
  discount: Float!
  status: StatusOrderItem!
  order: Order!
  product: Product!
  createdAt: DateTime!
  updatedAt: DateTime!
  deleted: Boolean!
}

type OrderItemConnection {
  pageInfo: PageInfo!
  edges: [OrderItemEdge]!
  aggregate: AggregateOrderItem!
}

input OrderItemCreateInput {
  id: UUID
  quantity: Int!
  price: Float!
  discount: Float
  status: StatusOrderItem
  order: OrderCreateOneWithoutOrderItensInput!
  product: ProductCreateOneInput!
  deleted: Boolean
}

input OrderItemCreateManyWithoutOrderInput {
  create: [OrderItemCreateWithoutOrderInput!]
  connect: [OrderItemWhereUniqueInput!]
}

input OrderItemCreateWithoutOrderInput {
  id: UUID
  quantity: Int!
  price: Float!
  discount: Float
  status: StatusOrderItem
  product: ProductCreateOneInput!
  deleted: Boolean
}

type OrderItemEdge {
  node: OrderItem!
  cursor: String!
}

enum OrderItemOrderByInput {
  id_ASC
  id_DESC
  quantity_ASC
  quantity_DESC
  price_ASC
  price_DESC
  discount_ASC
  discount_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deleted_ASC
  deleted_DESC
}

type OrderItemPreviousValues {
  id: UUID!
  quantity: Int!
  price: Float!
  discount: Float!
  status: StatusOrderItem!
  createdAt: DateTime!
  updatedAt: DateTime!
  deleted: Boolean!
}

input OrderItemScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  discount: Float
  discount_not: Float
  discount_in: [Float!]
  discount_not_in: [Float!]
  discount_lt: Float
  discount_lte: Float
  discount_gt: Float
  discount_gte: Float
  status: StatusOrderItem
  status_not: StatusOrderItem
  status_in: [StatusOrderItem!]
  status_not_in: [StatusOrderItem!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  AND: [OrderItemScalarWhereInput!]
  OR: [OrderItemScalarWhereInput!]
  NOT: [OrderItemScalarWhereInput!]
}

type OrderItemSubscriptionPayload {
  mutation: MutationType!
  node: OrderItem
  updatedFields: [String!]
  previousValues: OrderItemPreviousValues
}

input OrderItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderItemWhereInput
  AND: [OrderItemSubscriptionWhereInput!]
  OR: [OrderItemSubscriptionWhereInput!]
  NOT: [OrderItemSubscriptionWhereInput!]
}

input OrderItemUpdateInput {
  quantity: Int
  price: Float
  discount: Float
  status: StatusOrderItem
  order: OrderUpdateOneRequiredWithoutOrderItensInput
  product: ProductUpdateOneRequiredInput
  deleted: Boolean
}

input OrderItemUpdateManyDataInput {
  quantity: Int
  price: Float
  discount: Float
  status: StatusOrderItem
  deleted: Boolean
}

input OrderItemUpdateManyMutationInput {
  quantity: Int
  price: Float
  discount: Float
  status: StatusOrderItem
  deleted: Boolean
}

input OrderItemUpdateManyWithoutOrderInput {
  create: [OrderItemCreateWithoutOrderInput!]
  delete: [OrderItemWhereUniqueInput!]
  connect: [OrderItemWhereUniqueInput!]
  set: [OrderItemWhereUniqueInput!]
  disconnect: [OrderItemWhereUniqueInput!]
  update: [OrderItemUpdateWithWhereUniqueWithoutOrderInput!]
  upsert: [OrderItemUpsertWithWhereUniqueWithoutOrderInput!]
  deleteMany: [OrderItemScalarWhereInput!]
  updateMany: [OrderItemUpdateManyWithWhereNestedInput!]
}

input OrderItemUpdateManyWithWhereNestedInput {
  where: OrderItemScalarWhereInput!
  data: OrderItemUpdateManyDataInput!
}

input OrderItemUpdateWithoutOrderDataInput {
  quantity: Int
  price: Float
  discount: Float
  status: StatusOrderItem
  product: ProductUpdateOneRequiredInput
  deleted: Boolean
}

input OrderItemUpdateWithWhereUniqueWithoutOrderInput {
  where: OrderItemWhereUniqueInput!
  data: OrderItemUpdateWithoutOrderDataInput!
}

input OrderItemUpsertWithWhereUniqueWithoutOrderInput {
  where: OrderItemWhereUniqueInput!
  update: OrderItemUpdateWithoutOrderDataInput!
  create: OrderItemCreateWithoutOrderInput!
}

input OrderItemWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  discount: Float
  discount_not: Float
  discount_in: [Float!]
  discount_not_in: [Float!]
  discount_lt: Float
  discount_lte: Float
  discount_gt: Float
  discount_gte: Float
  status: StatusOrderItem
  status_not: StatusOrderItem
  status_in: [StatusOrderItem!]
  status_not_in: [StatusOrderItem!]
  order: OrderWhereInput
  product: ProductWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  AND: [OrderItemWhereInput!]
  OR: [OrderItemWhereInput!]
  NOT: [OrderItemWhereInput!]
}

input OrderItemWhereUniqueInput {
  id: UUID
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  subTotal_ASC
  subTotal_DESC
  total_ASC
  total_DESC
  statusOrder_ASC
  statusOrder_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deleted_ASC
  deleted_DESC
}

type OrderPreviousValues {
  id: UUID!
  subTotal: Float!
  total: Float!
  statusOrder: StatusOrder!
  createdAt: DateTime!
  updatedAt: DateTime!
  deleted: Boolean!
}

input OrderScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  subTotal: Float
  subTotal_not: Float
  subTotal_in: [Float!]
  subTotal_not_in: [Float!]
  subTotal_lt: Float
  subTotal_lte: Float
  subTotal_gt: Float
  subTotal_gte: Float
  total: Float
  total_not: Float
  total_in: [Float!]
  total_not_in: [Float!]
  total_lt: Float
  total_lte: Float
  total_gt: Float
  total_gte: Float
  statusOrder: StatusOrder
  statusOrder_not: StatusOrder
  statusOrder_in: [StatusOrder!]
  statusOrder_not_in: [StatusOrder!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  AND: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateInput {
  subTotal: Float
  total: Float
  orderItens: OrderItemUpdateManyWithoutOrderInput
  statusOrder: StatusOrder
  customer: CustomerUpdateOneRequiredWithoutOrdersInput
  deleted: Boolean
}

input OrderUpdateManyDataInput {
  subTotal: Float
  total: Float
  statusOrder: StatusOrder
  deleted: Boolean
}

input OrderUpdateManyMutationInput {
  subTotal: Float
  total: Float
  statusOrder: StatusOrder
  deleted: Boolean
}

input OrderUpdateManyWithoutCustomerInput {
  create: [OrderCreateWithoutCustomerInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutCustomerInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutCustomerInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput!
  data: OrderUpdateManyDataInput!
}

input OrderUpdateOneRequiredWithoutOrderItensInput {
  create: OrderCreateWithoutOrderItensInput
  update: OrderUpdateWithoutOrderItensDataInput
  upsert: OrderUpsertWithoutOrderItensInput
  connect: OrderWhereUniqueInput
}

input OrderUpdateWithoutCustomerDataInput {
  subTotal: Float
  total: Float
  orderItens: OrderItemUpdateManyWithoutOrderInput
  statusOrder: StatusOrder
  deleted: Boolean
}

input OrderUpdateWithoutOrderItensDataInput {
  subTotal: Float
  total: Float
  statusOrder: StatusOrder
  customer: CustomerUpdateOneRequiredWithoutOrdersInput
  deleted: Boolean
}

input OrderUpdateWithWhereUniqueWithoutCustomerInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutCustomerDataInput!
}

input OrderUpsertWithoutOrderItensInput {
  update: OrderUpdateWithoutOrderItensDataInput!
  create: OrderCreateWithoutOrderItensInput!
}

input OrderUpsertWithWhereUniqueWithoutCustomerInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutCustomerDataInput!
  create: OrderCreateWithoutCustomerInput!
}

input OrderWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  subTotal: Float
  subTotal_not: Float
  subTotal_in: [Float!]
  subTotal_not_in: [Float!]
  subTotal_lt: Float
  subTotal_lte: Float
  subTotal_gt: Float
  subTotal_gte: Float
  total: Float
  total_not: Float
  total_in: [Float!]
  total_not_in: [Float!]
  total_lt: Float
  total_lte: Float
  total_gt: Float
  total_gte: Float
  orderItens_every: OrderItemWhereInput
  orderItens_some: OrderItemWhereInput
  orderItens_none: OrderItemWhereInput
  statusOrder: StatusOrder
  statusOrder_not: StatusOrder
  statusOrder_in: [StatusOrder!]
  statusOrder_not_in: [StatusOrder!]
  customer: CustomerWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: UUID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Product {
  id: UUID!
  description: String!
  suggestedPrice: Float!
  store: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  deleted: Boolean!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: UUID
  description: String!
  suggestedPrice: Float!
  store: Int
  deleted: Boolean
}

input ProductCreateOneInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  suggestedPrice_ASC
  suggestedPrice_DESC
  store_ASC
  store_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deleted_ASC
  deleted_DESC
}

type ProductPreviousValues {
  id: UUID!
  description: String!
  suggestedPrice: Float!
  store: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  deleted: Boolean!
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateDataInput {
  description: String
  suggestedPrice: Float
  store: Int
  deleted: Boolean
}

input ProductUpdateInput {
  description: String
  suggestedPrice: Float
  store: Int
  deleted: Boolean
}

input ProductUpdateManyMutationInput {
  description: String
  suggestedPrice: Float
  store: Int
  deleted: Boolean
}

input ProductUpdateOneRequiredInput {
  create: ProductCreateInput
  update: ProductUpdateDataInput
  upsert: ProductUpsertNestedInput
  connect: ProductWhereUniqueInput
}

input ProductUpsertNestedInput {
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  suggestedPrice: Float
  suggestedPrice_not: Float
  suggestedPrice_in: [Float!]
  suggestedPrice_not_in: [Float!]
  suggestedPrice_lt: Float
  suggestedPrice_lte: Float
  suggestedPrice_gt: Float
  suggestedPrice_gte: Float
  store: Int
  store_not: Int
  store_in: [Int!]
  store_not_in: [Int!]
  store_lt: Int
  store_lte: Int
  store_gt: Int
  store_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: UUID
}

type Query {
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  manager(where: ManagerWhereUniqueInput!): Manager
  managers(where: ManagerWhereInput, orderBy: ManagerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Manager]!
  managersConnection(where: ManagerWhereInput, orderBy: ManagerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ManagerConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  orderItem(where: OrderItemWhereUniqueInput!): OrderItem
  orderItems(where: OrderItemWhereInput, orderBy: OrderItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderItem]!
  orderItemsConnection(where: OrderItemWhereInput, orderBy: OrderItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderItemConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  node(id: ID!): Node
}

enum StatusOrder {
  CANCELED
  APPROVED
  ANALYZING
}

enum StatusOrderItem {
  CANCELED
  OK
}

type Subscription {
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  manager(where: ManagerSubscriptionWhereInput): ManagerSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  orderItem(where: OrderItemSubscriptionWhereInput): OrderItemSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
}

scalar UUID
`